package wrm.exmo.test;import java.lang.reflect.Method;import java.util.Date;import java.util.HashMap;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;;/** * Simple DDL (data description language) first: register your classes then: * register variables then: use * SDDL.create("myClass { id:1234, myDate:$myVar.aProperty } > resultVarName") * after that: be happy *  *  * restrictions: registered classes must have noargs-constructor there must be a * oneArg setter for properties the type of the property must have a * String-Constructor *  *  * @author D053698 */public class SDDL {	Map<String, Class> registeredTypes = new HashMap<String, Class>();	public void registerClass(Class<?> clazz) {		registeredTypes.put(clazz.getSimpleName(), clazz);	}	public void registerClass(Class<?> clazz, String alias) {		registeredTypes.put(alias, clazz);	}	Map<String, Object> variables = new HashMap<String, Object>();	public void registerVariable(String alias, Object val) {		variables.put(alias, val);	}	Map<Class, Class> typeMappings = new HashMap<Class, Class>() {		{			put(int.class, Integer.class);			put(char.class, Character.class);			put(boolean.class, Boolean.class);			put(long.class, Long.class);			put(float.class, Float.class);			put(double.class, Double.class);		}	};	public <T> T create(String desc) throws Exception {		int sIdx = desc.indexOf('{');		int eIdx = desc.indexOf('}');		String typeId = desc.substring(0, sIdx).trim();		Class regClass = registeredTypes.get(typeId);		if (regClass == null)			throw new Exception("Type not registered: " + typeId);		T cur = (T) regClass.newInstance();		String propString = desc.substring(sIdx + 1, eIdx);		String[] propVal = propString.split(",");		Method[] methods = cur.getClass().getMethods();		for (String kvPair : propVal) {			String[] kv = kvPair.split(":", 2);											Method m = findSetter(methods, kv[0].trim());			Object convertedParam = getConvertedParam(m, kv[1].trim());			m.invoke(cur, convertedParam);		}		int saveOpIdx = desc.substring(eIdx + 1).indexOf('>');		if (saveOpIdx > 0) {			String varName = desc.substring(eIdx + 1).substring(saveOpIdx + 1);			variables.put(varName.trim(), cur);		}		return cur;	}	private Object getConvertedParam(Method m, String param) throws Exception {		if (param.startsWith("$"))			return retrieveProperty(param.substring(1));		Class<?> class1 = m.getParameterTypes()[0];		if (typeMappings.containsKey(class1)) {			class1 = typeMappings.get(class1);		} else if (class1 == Date.class) {			return new Date(Long.parseLong(param));		}		return class1.getConstructor(String.class).newInstance(param);	}	private Object retrieveProperty(String varName) throws Exception {		String[] varNameProps = varName.split("\\.");		Object cur = variables.get(varNameProps[0]);		for (int i = 1; i < varNameProps.length; ++i) {			Method getter = findGetter(cur.getClass().getMethods(),					varNameProps[i]);			cur = getter.invoke(cur);		}		return cur;	}	private Method findGetter(Method[] methods, String key) throws Exception {		return findMethod(methods, "get" + capitalize(key));	}	private Method findSetter(Method[] methods, String key) throws Exception {		return findMethod(methods, "set" + capitalize(key));	}	private Method findMethod(Method[] methods, String methodName)			throws Exception {		for (Method m : methods)			if (m.getName().equals(methodName))				return m;		throw new Exception("Cant find method:" + methodName);	}	private String capitalize(String key) {		return Character.toUpperCase(key.charAt(0)) + key.substring(1);	}}